import asyncio

from discord.ext import commands
from dotenv import load_dotenv

from src.entity.Port22 import port22
from src.entity.Port443 import port443
from src.entity.Port80 import port80
# import entity.Port22 as port22
# import entity.Port443 as port443
# import entity.Port80 as port80
from src.entity.UsersData import Users
from src.utils import functions as util

load_dotenv()


class Tools(commands.Cog):
    encodeNormalPass = "unpxgurobk"
    host = "antoine@192.168.0.0"
    webLogin = "shine102@antoineHackerLord.com"
    website = 'antoineHackerLord.com'

    def __init__(self, bot):
        self.bot = bot

    @commands.Cog.listener()
    async def on_ready(self):
        print('Bot is online')

    @commands.command()
    @commands.dm_only()
    async def start(self, ctx, *args):
        if len(args) == 0:
            Users.users[ctx.author.id] = Users()
            await ctx.send(embed=util.embedColor(
                f'R·∫•t m·ª´ng khi ƒë∆∞·ª£c g·∫∑p l·∫°i trong nhi·ªám v·ª• l·∫ßn n√†y, EHC ƒë√£ x√°c nh·∫≠n nh·ªØng cu·ªôc t·∫•n c√¥ng m·∫°ng t·ªõi m√°y ch·ªß c·ªßa ch√≠nh ph·ªß nh·∫±m chi·∫øm ƒëo·∫°t l·∫•y Key, l√† ch√¨a kh√≥a ƒë·ªÉ ph√≥ng 1 ƒë·∫ßu ƒë·∫°n h·∫°t nh√¢n, n·∫øu h·∫µn c√≥ th·ªÉ k√≠ch ho·∫°t ƒë∆∞·ª£c th√¨ n√≥ s·∫Ω m·ªü ra 1 cu·ªôc th·∫£m s√°t h·∫°t nh√¢n v√† l√† c∆° s·ªü ƒë·ªÉ c√°c qu·ªëc gia c·∫Øn x√© l·∫´n nhau, tr·∫≠t t·ª± b·ªã ƒë·∫£o l·ªôn, h√≤a b√¨nh s·∫Ω kh√¥ng c√≤n t·ªìn t·∫°i n·ªØa\n',
                "", "STORY"))
            await asyncio.sleep(10)
            await ctx.send(embed=util.embedColor(
                'C√≥ m·ªôt v√†i d·∫•u v·∫øt hacker ƒë√£ ƒë·ªÉ l·∫°i m√† ch√∫ng t√¥i c√≥ th·ªÉ t√¨m th·∫•y ƒë∆∞·ª£c. EHC nghi ng·ªù r·∫±ng Antoine, 1 ph·∫ßn t·ª≠ kh·ªßng b·ªë, ng∆∞·ªùi ƒë√£ k√≠ch ƒë·ªông c√°ch m·∫°ng b·∫±ng c√°ch th·ª±c hi·ªán c√°c h√†nh ƒë·ªông kh·ªßng b·ªë ·ªü nhi·ªÅu qu·ªëc gia l√† ng∆∞·ªùi ƒë·ª©ng sau t·∫•m m√†n.\n',
                "", "STORY"))
            await asyncio.sleep(7)
            await ctx.send(embed=util.embedColor(
                'Nhi·ªám v·ª• c·ªßa b·∫°n, d√π b·∫°n ch·ªçn ch·∫•p nh·∫≠n, ƒë√≥ l√† th√¢m nh·∫≠p v√†o m√°y ch·ªß c·ªßa h·∫Øn, ƒëo·∫°t l·∫°i Key c≈©ng nh∆∞ t√¨m th·ªùi gian di·ªÖn ra cu·ªôc t·∫•n c√¥ng. N·∫øu nh∆∞ b·∫°n b·ªã b·∫Øt ho·∫∑c b·ªã gi·∫øt trong th·ªùi gian th·ª±c thi nhi·ªám v·ª•, EHC s·∫Ω t·ª´ ch·ªëi m·ªçi th√¥ng tin li√™n quan t·ªõi h√†nh ƒë·ªông n√†o c·ªßa b·∫°n. Ch√∫c may m·∫Øn.\n',
                "", "MISSION"))
            await asyncio.sleep(10)
            await ctx.send(embed=util.embedColor(
                "M·ªôt v√†i note cho b·∫°n: \n  - Key m√† b·∫°n c·∫ßn t√¨m l√†: EHC{..._..._..._...}\n  - H√£y c·∫©n th·∫≠n c√°c d·∫•u c√°ch(space) trong c√¢u l·ªánh, ch√∫ng r·∫•t l√† quan trong.\n  - N·∫øu b·∫°n g·∫∑p ph·∫£i b·∫•t k√¨ lo·∫°i m√£ h√≥a n√†o th√¨ b·∫°n c√≥ th·ªÉ t√¨m ki·∫øm nh·ªØng ph∆∞∆°ng th·ª©c gi·∫£i m√£ tr·ª±c tuy·∫øn v·ªõi t·ª´ kh√≥a nh∆∞ 'encryption_name + decoder + online'\n\nOK LET'S BEGIN",
                "fix", "NOTE"))
            await asyncio.sleep(7)
            await ctx.send(embed=util.embedColor(
                f"Host address: {self.host}\nPassword: {self.encodeNormalPass}\nƒê√¢y l√† nh·ªØng th√¥ng tin m√† ch√∫ng t√¥i c√≥ th·ªÉ t√¨m ƒë∆∞·ª£c, tuy kh√¥ng bi·∫øt m·∫≠t kh·∫©u c·ªßa port n√†o nh∆∞ng n√≥ ƒë√£ b·ªã m√£ h√≥a b·∫±ng ROT13, h√£y th·ª≠ gi·∫£i m√£ n√≥ üò•",
                "", "INFORMATION YOU NEED"))
            await asyncio.sleep(7)
            await ctx.send(embed=util.embedColor(
                "Vi·ªác b·∫°n c·∫ßn l√†m ti·∫øp theo ƒë√≥ l√† scan host ho·∫∑c website ƒë·ªÉ c√≥ th·ªÉ t√¨m ƒë∆∞·ª£c ra c·ªïng ƒë·ªÉ c√≥ th·ªÉ k·∫øt n·ªëi t·ªõi\nƒê·ªÉ scan ƒë∆∞·ª£c 1 host th√¨ b·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng l·ªánh scan: $scan host/address/website",
                "", "SCAN COMMAND"))
        else:
            raise commands.CommandInvokeError(self, Exception)

    @start.error
    async def start_error(self, ctx, error):
        if isinstance(error, commands.CommandInvokeError):
            await ctx.send(
                embed=util.embedColor("Nh·∫≠p sai l·ªánh, h√£y nh·∫≠p $start", "diff", "START"))

    @commands.command()
    @commands.dm_only()
    async def scan(self, ctx, *args):
        if len(args) == 1:
            if args[0] == self.host:  # if the correct host then return the portal
                await ctx.send(embed=util.embedColor(f"{self.host} tr·∫£ v·ªÅ port: 80, 22\n", "", "SCAN RESULT"))
                await asyncio.sleep(2)
                await ctx.send(embed=util.embedColor(
                    'ƒê·ªÉ c√≥ th·ªÉ k·∫øt n·ªëi t·ªõi host b·∫°n c·∫ßn s·ª≠ d·ª•ng l·ªánh ssh(m·ªôt giao th·ª©c m·∫°ng c√≥ th·ªÉ cung c·∫•p 1 ph∆∞∆°ng ph√°p k·∫øt n·ªëi b·∫£o m·∫≠t t·ªõi 1 m√°y t√≠nh t·ª´ xa\nƒê·ªÉ hi·ªÉu h∆°n, b·∫°n c√≥ th·ªÉ truy c·∫≠p v√†o ƒë∆∞·ªùng link: '
                    + 'https://www.techtarget.com/searchsecurity/definition/Secure-Shell\n'
                    + 'l·ªánh SSH: $ssh host address -p port_number\n', "", "SSH COMMAND"))
            elif args[0] == self.website:
                await ctx.send(embed=util.embedColor(f"{self.website} tr·∫£ v·ªÅ port: 443\n", "", "SCAN RESULT"))
                await asyncio.sleep(5)
                await ctx.send(embed=util.embedColor(
                    'ƒê·ªÉ k·∫øt n·ªëi t·ªõi website th√¨ b·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng l·ªánh ssh nh∆∞ l√∫c tr∆∞·ªõc nh∆∞ng c√≥ 1 v√†i s·ª± thay ƒë·ªïi '
                    + 'l·ªánh SSH: $ssh UserName@SSHserver.example.com  -p port_number\n', "", "SSH COMMAND"))
            else:
                await ctx.send(embed=util.embedColor("'Port k·∫øt n·ªëi t·ªõi kh√¥ng kh·∫£ d·ª•ng\n'", "diff", "ERROR"))
        else:
            raise commands.CommandInvokeError(self, Exception)

    @scan.error
    async def scan_error(self, ctx, error):
        if isinstance(error, commands.CommandInvokeError):
            await ctx.send(
                embed=util.embedColor(
                    "Thi·∫øu ho·∫∑c th·ª´a c√°c tham s·ªë trong c√¢u l·ªánh\nC√°ch s·ª≠ d·ª•ng: scan host_name/website\n",
                    "diff", "ERROR"))

    @commands.command()
    @commands.dm_only()
    async def ssh(self, ctx, *args):
        if len(args) == 3:
            if Users.users[ctx.author.id].Login:  # check if user have entered already
                await ctx.send(util.syntaxHighlight(
                    f"'B·∫°n ƒë√£ k·∫øt n·ªëi t·ªõi host {self.host} port {Users.users[ctx.author.id].portNumber}\nB·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng l·ªánh $exit ƒë·ªÉ tho√°t ra kh·ªèi host k·∫øt n·ªëi hi·ªán t·∫°i",
                    ""))
            else:
                if args[1] != '-p':
                    await ctx.send(
                        embed=util.embedColor("- Thu·ªôc t√≠nh kh√¥ng ƒë√∫ng. B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng '-p' ", "diff", "ERROR"))
                else:
                    match args[2]:
                        case '80':
                            if args[0] != self.host:
                                await ctx.send(
                                    embed=util.embedColor("- Host k·∫øt n·ªëi kh√¥ng kh·∫£ d·ª•ng - ", "diff", "ERROR"))
                            else:
                                Users.users[ctx.author.id].port = port80()
                                Users.users[ctx.author.id].portNumber = args[2]
                                await Users.users[ctx.author.id].port.loginCheck(ctx)
                        case '22':
                            if args[0] != self.host:
                                await ctx.send(
                                    embed=util.embedColor("- Host k·∫øt n·ªëi kh√¥ng kh·∫£ d·ª•ng - ", "diff", "ERROR"))
                            else:
                                Users.users[ctx.author.id].port = port22()
                                Users.users[ctx.author.id].portNumber = args[2]
                                await Users.users[ctx.author.id].port.loginCheck(ctx)
                        case '443':
                            if args[0] != self.webLogin:
                                await ctx.send(
                                    embed=util.embedColor("- Host k·∫øt n·ªëi kh√¥ng kh·∫£ d·ª•ng - ", "diff", "ERROR"))
                            else:
                                Users.users[ctx.author.id].port = port443()
                                Users.users[ctx.author.id].portNumber = args[2]
                                await Users.users[ctx.author.id].port.loginCheck(ctx)
                        case _:
                            await ctx.send(
                                embed=util.embedColor(f"Host hi·ªán t·∫°i kh√¥ng c√≥ port {args[2]} ƒë·ªÉ k·∫øt n·ªëi\n", "diff",
                                                      "ERROR"))
                    if Users.users[ctx.author.id].Login == False:
                        Users.users[ctx.author.id].port = None
                        Users.users[ctx.author.id].portNumber = None
        else:
            raise commands.CommandInvokeError(self, Exception)

    @ssh.error
    async def ssh_error(self, ctx, error):
        if isinstance(error, commands.CommandInvokeError):
            await ctx.send(
                embed=util.embedColor(
                    "- Thi·∫øu ho·∫∑c th·ª´a c√°c tham s·ªë trong c√¢u l·ªánh.\nC√°ch s·ª≠ d·ª•ng: ssh host_address -p port_number\n",
                    "diff",
                    "ERROR"))

    @commands.command()
    @commands.dm_only()
    async def exit(self, ctx, *args):
        if Users.users[ctx.author.id].Login and len(args) == 0:  # if user have login to the host, then exit
            if Users.users[ctx.author.id].portNumber == '80' or Users.users[ctx.author.id].portNumber == '22':
                await ctx.send(
                    embed=util.embedColor(
                        'Tho√°t ra host: ' + self.host + ' port ' + Users.users[
                            ctx.author.id].portNumber + ' th√†nh c√¥ng\n',
                        'diff', "Exit Successfully"))
            elif Users.users[ctx.author.id].portNumber == '443':
                await ctx.send(
                    embed=util.embedColor(
                        'Tho√°t ra host: ' + self.website + ' port ' + Users.users[
                            ctx.author.id].portNumber + ' th√†nh c√¥ng\n',
                        'diff', 'Exit Successfully'))
            Users.users[ctx.author.id].Login = False
            Users.users[ctx.author.id].portNumber = None
        else:  # if not
            raise commands.CommandInvokeError(self, Exception)

    @exit.error
    async def exit_error(self, ctx, error):
        if isinstance(error, commands.CommandInvokeError) and Users.users[ctx.author.id].Login == True:
            await ctx.send(util.syntaxHighlight("- Th·ª´a gi√° tr·ªã trong c√¢u l·ªánh -", "diff"))
        if isinstance(error, commands.CommandInvokeError) and Users.users[ctx.author.id].Login == False:
            await ctx.send(util.syntaxHighlight("- H√£y ƒëƒÉng nh·∫≠p tr∆∞·ªõc ti√™n ! -", "diff"))

    @commands.command()
    @commands.dm_only()
    async def ls(self, ctx, *args):
        if Users.users[ctx.author.id].Login:
            if len(args) == 0:
                await Users.users[ctx.author.id].port.listAllFile(ctx)
            else:
                if args[0] == "-a" and Users.users[ctx.author.id].portNumber == '443' and len(args) == 1:
                    await Users.users[ctx.author.id].port.listAllHiddenFile(ctx)
                elif args[0] == "-a" and (
                        Users.users[ctx.author.id].portNumber == '80' or Users.users[
                    ctx.author.id].portNumber == '22') and len(args) == 1:
                    await Users.users[ctx.author.id].port.listAllFile(ctx)
                else:
                    raise commands.CommandInvokeError(self, Exception)
        else:
            raise commands.CommandInvokeError(self, Exception)

    @ls.error
    async def ls_error(self, ctx, error):
        if isinstance(error, commands.CommandInvokeError) and Users.users[ctx.author.id].Login == True:
            await ctx.send(util.syntaxHighlight("- Thu·ªôc t√≠nh kh√¥ng ƒë√∫ng, b·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng '-a' -", "diff"))
        if isinstance(error, commands.CommandInvokeError) and Users.users[ctx.author.id].Login == False:
            await ctx.send(util.syntaxHighlight("- H√£y ƒëƒÉng nh·∫≠p tr∆∞·ªõc ti√™n ! -", "diff"))

    @commands.command()
    @commands.dm_only()
    async def cat(self, ctx, *args):
        if Users.users[ctx.author.id].Login and len(args) == 1:
            await Users.users[ctx.author.id].port.cat(ctx, args[0])
        else:
            raise commands.CommandInvokeError(self, Exception)

    @cat.error
    async def cat_error(self, ctx, error):
        if isinstance(error, commands.CommandInvokeError) and Users.users[ctx.author.id].Login == True:
            await ctx.send(
                embed=util.embedColor("- Th·ª´a gi√° tr·ªã trong c√¢u l·ªánh, c√°ch s·ª≠ d·ª•ng: $cat file -\n", "diff", "ERROR"))
        if isinstance(error, commands.CommandInvokeError) and Users.users[ctx.author.id].Login == False:
            await ctx.send(util.syntaxHighlight("- H√£y ƒëƒÉng nh·∫≠p tr∆∞·ªõc ti√™n ! -", "diff"))


async def setup(bot):
    await bot.add_cog(Tools(bot))
